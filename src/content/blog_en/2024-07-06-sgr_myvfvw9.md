---
title: "[Rust] thirtyfour Webdriver Auto-Update and Execution"
slug: sgr_myvfvw9
description: Explains how to automatically update Webdriver in Rust's web automation tool thirtyfour. By reusing SeleniumManager, you can easily manage Webdriver versions. Introduces a method to achieve web scraping or test automation easily without Docker.
date: 2024-07-06T11:06:27.997Z
preview: https://pub-21c8df4785a6478092d6eb23a55a5c42.r2.dev/img%2Feyecatch%2Fthirtyfour_auto.webp
draft: false
tags: ['Selenium', 'thirtyfour', 'Rust']
categories: ['Programming']
---

# [Rust] thirtyfour Webdriver Auto-Update and Execution

[thirtyfour](https://crates.io/crates/thirtyfour) for Rust is a tool that uses Webdriver, similar to Selenium or Playwright, to automate browser actions for testing web apps, scraping, or value verification. To implement automation with thirtyfour, the standard procedure involves installing the corresponding Webdriver in advance according to the browser version and then executing it. Since Webdriver needs to be updated every time the browser is updated, this can be a tedious process, and when passing programs to non-technical users, issues with Webdriver updates often occur.

In Selenium for other languages like Python, there is an executable called SeleniumManager bundled within Selenium, which automatically updates Webdriver and provides the path of the updated Webdriver to Selenium to launch it automatically. Among these, SeleniumManager, which handles Webdriver auto-updates, is written in Rust and managed on GitHub, so it can be reused in Rust to enable automatic Webdriver updates for thirtyfour.

Here are the procedures and sample code.

## Code

The key point of this code is to reuse SeleniumManager to achieve WebDriver updates in Rust without hassle. The source code of SeleniumManager can be found on [GitHub](https://github.com/SeleniumHQ/selenium/tree/trunk/rust).

### cargo.toml

In cargo.toml, describe to load selenium-manager from GitHub. Also, introduce necessary crates such as thirtyfour and tokio.
```toml
[package]
name = ""
version = "0.1.0"
edition = "2021"

[dependencies]
selenium-manager = { git = "https://github.com/SeleniumHQ/selenium", branch = "trunk" }
thirtyfour = "0.31.0"
tokio = "1.38.0"
```

### main.rs
```rust
use selenium_manager::get_manager_by_browser;
use std::error::Error;
use std::process::Command;
use std::time::Duration;
use thirtyfour::prelude::*;

struct ChromeDriverManager {
    driver_path: String,
}

impl ChromeDriverManager {
    async fn new(browser: String) -> Result<Self, Box<dyn Error + Send + Sync>> {
        let driver_path = tokio::task::spawn_blocking(move || {
            let mut manager = get_manager_by_browser(browser)?;
            Ok::<_, Box<dyn Error + Send + Sync>>(manager.setup()?.to_str().ok_or("Invalid path")?.to_string())
        })
            .await??;

        Ok(Self { driver_path })
    }

    fn start(&self) -> Result<(), Box<dyn Error + Send + Sync>> {
        Command::new(&self.driver_path)
            .spawn()
            .map_err(|e| format!("ChromeDriverの起動に失敗しました: {}", e))?;
        std::thread::sleep(Duration::from_secs(2)); // 起動待機
        Ok(())
    }
}

async fn run_browser_session() -> Result<(), Box<dyn Error + Send + Sync>> {
    let driver = WebDriver::new("http://localhost:9515", DesiredCapabilities::chrome()).await?;
    driver.goto("https://www.example.com").await?;
    println!("Page title: {}", driver.title().await?);
    driver.quit().await?;
    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {
    let chromedriver_manager = ChromeDriverManager::new("chrome".to_string()).await?;
    chromedriver_manager.start()?;
    run_browser_session().await
}
```

## Explanation

After adding dependencies to cargo.toml, by writing `use selenium_manager::get_manager_by_browser;`, you can reuse SeleniumManager. By inputting the browser name to get_manager_by_browser, it automatically installs the corresponding browser's Webdriver and obtains the string of its file path. Then, by executing start, the corresponding version's Webdriver can be run automatically via command.

The subsequent steps are the same as the usual thirtyfour code description. As a sample code, it only processes accessing example.com and outputting its page title.

## Summary

Usually, Webdriver updates are also necessary along with browser version updates, but by using SeleniumManager, this procedure can be omitted. There is also a method to use Docker to run Selenium on a container, but with this method, Docker is not needed, making it easier to pass to non-technical users for automation such as testing, scraping, or crawling. Since it only requires reusing SeleniumManager, it's a handy method for developers as well, so please try it out.